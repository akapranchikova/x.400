import {
  messageContentSchema,
  messageEnvelopeSchema,
  messageSchema,
  reportSchema,
  x400AddressSchema,
  type Message,
  type MessageContent,
  type MessageEnvelope,
  type Report,
  type X400Address,
} from '../schemas';
export * as arb from './arb';
import { addMinutes } from '../utils';

export function randomUUID() {
  return typeof crypto !== 'undefined' && 'randomUUID' in crypto
    ? crypto.randomUUID()
    : Math.random().toString(36).substring(2) + Date.now().toString(36);
}

export type PartialDeep<T> = {
  [P in keyof T]?: T[P] extends (infer U)[]
    ? PartialDeep<U>[]
    : T[P] extends object
      ? PartialDeep<T[P]>
      : T[P];
};

const baseAddress: X400Address = x400AddressSchema.parse({
  orName: {
    c: 'DE',
    o: 'Modernization',
    surname: 'Operator',
  },
  dda: [],
  routingHints: [],
});

const baseEnvelope: MessageEnvelope = messageEnvelopeSchema.parse({
  id: randomUUID(),
  subject: 'Modernization test message',
  sender: baseAddress,
  to: [baseAddress],
  cc: [],
  bcc: [],
  priority: 'normal',
  sensitivity: 'normal',
  folder: 'inbox',
  status: 'delivered',
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString(),
  messageId: '<test@modernized.x400>',
});

const baseContent: MessageContent = messageContentSchema.parse({
  text: 'This is a canned message body generated by the shared test factory.',
  attachments: [],
});

const baseReport: Report = reportSchema.parse({
  id: randomUUID(),
  messageId: baseEnvelope.id,
  type: 'delivery',
  timestamp: new Date().toISOString(),
  recipient: baseEnvelope.sender,
});

function deepMerge<T extends Record<string, any>>(base: T, overrides: PartialDeep<T>): T {
  const output: Record<string, any> = Array.isArray(base) ? [...(base as unknown[])] : { ...base };

  for (const [key, value] of Object.entries(overrides ?? {})) {
    if (value === undefined) continue;
    const existing = (output as Record<string, any>)[key];

    if (Array.isArray(value)) {
      (output as Record<string, any>)[key] = value.map((item, index) => {
        if (typeof item === 'object' && item !== null && Array.isArray(existing)) {
          const existingItem = existing[index] ?? {};
          return deepMerge(existingItem, item as any);
        }
        return item;
      });
      continue;
    }

    if (
      typeof value === 'object' &&
      value !== null &&
      typeof existing === 'object' &&
      existing !== null
    ) {
      (output as Record<string, any>)[key] = deepMerge(existing, value as any);
      continue;
    }

    (output as Record<string, any>)[key] = value;
  }

  return output as T;
}

export function makeAddress(overrides: PartialDeep<X400Address> = {}): X400Address {
  return x400AddressSchema.parse(deepMerge(baseAddress, overrides));
}

export function makeEnvelope(overrides: PartialDeep<MessageEnvelope> = {}): MessageEnvelope {
  const base = {
    ...baseEnvelope,
    id: overrides.id ?? randomUUID(),
    messageId: overrides.messageId ?? `<${randomUUID()}@modernized.x400>`,
    createdAt: overrides.createdAt ?? new Date().toISOString(),
    updatedAt: overrides.updatedAt ?? new Date().toISOString(),
  } as MessageEnvelope;

  const merged = deepMerge(base, overrides);
  return messageEnvelopeSchema.parse(merged);
}

export function makeContent(overrides: PartialDeep<MessageContent> = {}): MessageContent {
  return messageContentSchema.parse(deepMerge(baseContent, overrides));
}

export function makeReport(overrides: PartialDeep<Report> = {}): Report {
  const merged = deepMerge(
    { ...baseReport, id: randomUUID(), timestamp: new Date().toISOString() },
    overrides,
  );
  return reportSchema.parse(merged);
}

export function makeMessage(overrides: PartialDeep<Message> = {}): Message {
  const envelope = makeEnvelope(overrides.envelope);
  const content = makeContent(overrides.content);
  const reports = overrides.reports?.map((report) =>
    makeReport({ messageId: envelope.id, ...report }),
  ) ?? [
    makeReport({ messageId: envelope.id }),
    makeReport({
      messageId: envelope.id,
      type: 'read',
      timestamp: addMinutes(new Date(), 2).toISOString(),
    }),
  ];

  return messageSchema.parse({
    envelope,
    content,
    reports,
  });
}

export function makeThread(count = 3): Message[] {
  return Array.from({ length: count }, (_, index) =>
    makeMessage({
      envelope: {
        subject: `Threaded message #${index + 1}`,
        folder: index === 0 ? 'inbox' : 'archive',
        status: index === 0 ? 'delivered' : 'read',
      },
    }),
  );
}
